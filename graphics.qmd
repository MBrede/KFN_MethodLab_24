---
toc-title: '![](imgs/elster_survival_model.webp){width=240px}<br> ggplot2'
---

```{r}
#| include: false
library(tidyverse)
knitr::opts_chunk$set(warning=F)
```

# *Grammar of Graphics* und `ggplot2` {#sec-ggplot}

## *Grammar of Graphics*

Hadley Wickhams Paket `ggplot2` versucht, die Erstellung von Grafiken in einer einheitlichen Grammatik, der "grammar of graphics", auszudrücken. Das Ziel hier ist es, nicht mehr in "Scatterplot" und "Boxplot" als einzelne Kategorien zu denken und diese einzeln erstellen lernen zu müssen, sondern alle Abbildungen mit derselben Logik erstellen zu können.

In Seinem Paper [@wickhamLayeredGrammarGraphics2010] werden die folgenden Komponenten als grundlegende Bausteine einer Grafik eingeführt:

>* a default dataset and set of mappings from variables to aesthetics,
* one or more layers, with each layer having one geometric object, one statistical trans-
formation, one position adjustment, and optionally, one dataset and set of aesthetic
mappings,
* one scale for each aesthetic mapping used,
* a coordinate system,
* the facet specification. *[@wickhamLayeredGrammarGraphics2010, p.8]*


### Komponenten eines Plots
Wir müssen für einen Plot also überlegen:

1. welche *Daten* wir auf welche *Aesthetics* mappen
2. welche *geometrischen Objekte* wir in welcher Reihenfolge auf die Grafik layer wollen und ob diese optionale andere Daten benötigen
3. welche *Skala* wir für die Mappings nutzen wollen
4. welches *Koordinatensystem* wir nutzen wollen
5. in welchen *Facetten* wir die Daten darstellen wollen


## Komponenten in `ggplot2`

#### Beispieldaten

:::: {.columns}

::: {.column width="40%"}
![Pinguine im Eis](imgs/palmer_penguins.png){width=80%}
:::

::: {.column width="60%"}
Im `palmerpenguins`-Paket werden Pinguin-Beobachtungen der [Palmer-Station in der Antarktis](https://pallter.marine.rutgers.edu/) zur Verfügung gestellt:

```{r}
palmerpenguins::penguins %>% 
  head()
```

:::

::::


### 1. Daten und Aesthetics - `ggplot()` + `aes()`


Wir wollen den Zusammenhang zwischen Körpergewicht und Schnabellänge über die Spezies betrachten. 
Dafür legen wir die "Leinwand" des Plots mit den zentralen mappings an:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species))
```


Dabei können natürlich je nach geom(s), die aufgeschaltet werden, unterschiedliche mappings relevant sein. Welche jeweils nötig sind, lässt sich auf der Hilfeseite des entsprechenden geoms nachlesen. 

Beispiele für mögliche Werte für die meisten mappings lassen sich in der ggplot2-Vignette zum Thema (`vignette("ggplot2-specs")`) finden.

### 2. Geometrische Objekte - `geom_*`

Diesem Plot fügen wir Punkte als geometrische Objekte hinzu, die uns zu einem Scatterplot führen:

```{r}
#| warning: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point()
```



### 3. Skalen - `scale_*`


Die Symbole und Farben haben genau wie x- und y- Koordinaten als ästhetische Mappings eigene Skalen. Wenn uns also die Farben nicht passen, können wir einfach eine andere Skala setzen:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point() +
  scale_color_viridis_d()
```



### 4. Koordinatensystem `coord_*`

Das Koordinatensystem passt von der Auflösung erstmal, aber wir wollen eine direkte Zuordnung von 10 mm Schnabellänge zu 1000 g Körpermasse. Dazu fügen wir eine `coord_*`-Spezifikation an:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point() +
  scale_color_viridis_d()+
  coord_fixed(ratio = 10/1000)
```


### 5. Facetten - `facet_*`

Als letzte Komponente überlegen wir uns, dass die verschiedenen Beobachtungspunkte als Einteilung interessant sein könnten und wir diese getrennt betrachten wollen. 
Mit der `facet`-Familie können wir den Graphen nach Indel facettieren:

```{r}
#| warning: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point() +
  scale_color_viridis_d()+
  coord_fixed(ratio = 10/1000) +
  facet_wrap(~island)
```

# *Grammar of Graphics* in `ggplot2`


## Einfache Grafiken {#sec-geoms}

```{r}
#| include: false

library(xml2)
library(rvest)

URL <- "https://cran.r-project.org/web/packages/ggplot2/index.html"

pg <- read_html(URL)

links <- html_attr(html_nodes(pg, "a"), "href")
links <- links[grepl('/(gg|Gg|GG)', links)]
```


Neben den dem Point-geom gibt es in `ggplot2` natürlich auch so gut wie alle anderen `geom`s, die für gängige Plots nötig sind. ^[Daneben gibt es einen riesigen Stamm an Paketen, die weniger gängige Plot-Typen als `geom`s implementieren, z.B. [`ggwordcloud`](https://lepennec.github.io/ggwordcloud/) für wordclouds, [`ggalluvial`](http://corybrunson.github.io/ggalluvial/) für Alluvial und Sankey-Diagramme, [`ggnet`](https://briatte.github.io/ggnet/) für Netzwerk-Plots und das bei meinen Studis sehr beliebte [`ggpubr`](https://rpkgs.datanovia.com/ggpubr/) für 'publication ready plots'. Auf cran sind im Moment `r length(links)` Pakete gelistet, die mit "gg" anfangen und `ggplot2` imoprtieren oder von `ggplot2` abhängig sind.]

Die folgende Auswahl ist nach dem System des sehr zu empfehlenden [Cheat-Sheets](https://www.rstudio.org/links/data_visualization_cheat_sheet) von posit zu `ggplot2` sortiert und nur ein Bruchteil der in R angelegten `geom`s.


:::{.panel-tabset}


### Eine Variable

:::{.panel-tabset}

#### kontinuierlich

Für die Darstellung einer numerischen Variable bieten Histogramme und ähnliche Darstellungen der Verteilungen einer Variable an.

In @fig-oneContinuous sind vier Beispiele, wie sich mit `ggplot2` eine numerische Variable darstellen ließe. Alle diese Plots haben den folgenden `ggplot`-Call als Grundlage:

```{r}
#| eval: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = flipper_length_mm))
```

```{r}
#| warning: false
#| layout-ncol: 2
#| layout-nrow: 2
#| echo: False
#| label: fig-oneContinuous
#| fig-cap: "Eine Auswahl der in `ggplot2` angelegten `geom`s, die die Verteilung einer Variable abbilden."
#| fig-subcap: 
#|   - "+ geom_histogram()"
#|   - "+ geom_dotplot()"
#|   - "+ geom_area(stat= 'bin')"
#|   - "+ geom_freqpoly()"
p <- palmerpenguins::penguins %>% 
  ggplot(aes(x = flipper_length_mm))

p + geom_histogram()
p + geom_dotplot()
p + geom_area(stat= 'bin')
p + geom_freqpoly()
```

Alle vier Beispiele berechnen dabei die bins in die die Beobachtungen einsortiert werden als Standard so, dass 30 Gruppen entstehen.

 <p class='q'>Welches der auf der `geom_histogram()`-Hilfeseite genannten Argumente hilft mir am ehesten, die Bin-Breite auf 5mm flipper-Length zu setzen?</p>

:::{class="card"}
:::{class="content"}

> binwidth	
The width of the bins. Can be specified as a numeric value or as a function that calculates width from unscaled x. Here, "unscaled x" refers to the original x values in the data, before application of any scale transformation. When specifying a function along with a grouping structure, the function will be called once per group. The default is to use the number of bins in bins, covering the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = flipper_length_mm)) +
  geom_histogram(binwidth=5)
```

Im Hilfetext wird auch die Möglichkeit eines Funktionsaufrufs genannt. Wenn wir zum Beispiel 5% des Abstands zwischen Maximum und Minimum des Wertebereichs als Binwidth setzen wollen, können wir den folgenden Call mit Lambda-Funktion benutzen.
Lambda-Funktionen sind anonyme Funktionen, für die in R 4.1.0 die Kurzschreibweise `\(x) <body> ` statt `function(x) <body>` eingeführt wurde. 

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = flipper_length_mm)) +
  geom_histogram(binwidth=\(x) .05 * (max(x, na.rm=T) - min(x, na.rm=T)))
```

:::
:::{class="overlay"}
Antwort aufdecken
:::
:::

#### diskret

Für eine diskrete Variable kann mit einem Barchart die Verteilung illustriert werden:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = island)) +
  geom_bar()
```

:::

### Zwei Variablen

:::{.panel-tabset}
#### Beide kontinuierlich

In @fig-twoContinous wird die Basis des `geom_point`-Blocks aus dem Anfang des `ggplot`-Abschnitts für alle vier Plots genutzt. Die Basis ist also in jedem Fall der folgende Code-Schnipsel:

```{r}
#| eval: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g))
```

```{r}
#| warning: false
#| layout-ncol: 2
#| layout-nrow: 2
#| echo: False
#| label: fig-twoContinous
#| fig-cap: "Eine Auswahl der in `ggplot2` angelegten `geom`s, die die Verteilung einer Variable abbilden."
#| fig-subcap: 
#|   - "+ geom_point()"
#|   - "+ geom_quantile()"
#|   - "+ geom_smooth(method = 'lm')"
#|   - "+ geom_rug(sides = 'bl')"
p <- palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species))

p + geom_point()
p + geom_quantile()
p + geom_smooth(method = 'lm')
p + geom_rug(sides = 'bl')
```


#### Eine diskret, eine kontinuierlich

Typische Darstellungen, die diskrete und kontinuierliche Variablen kombinieren, sind Darstellungen von Verteilungsvergleichen. Zum Beispiel könnte der Vergleich der Verteilungen der Schnabel-Länge zwischen den Spezies mit folgendem Call angelegt werden:

```{r}
#| eval: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = species, 
             y = bill_length_mm,
             color = species))
```

In @fig-oneContinousOneDiscrete sind drei Möglichkeiten abgetragen, wie sich diese Basis für eine Darstellung nutzen ließe.

```{r}
#| warning: false
#| layout-ncol: 2
#| echo: false
#| label: fig-oneContinousOneDiscrete
#| fig-cap: "Eine Auswahl der in `ggplot2` angelegten `geom`s, die die Verteilung einer Variable abbilden."
#| fig-subcap: 
#|   - "+ geom_boxplot()"
#|   - "+ geom_dotplot(binaxis = 'y', stackdir = 'center')"
#|   - "+ geom_violin(scale = 'area')"
p <- palmerpenguins::penguins %>% 
  ggplot(aes(x = species, 
             y = bill_length_mm,
             color = species))

p + geom_boxplot()
p + geom_dotplot(binaxis = 'y', stackdir = 'center')
p + geom_violin(scale = 'area')
```

Natürlich lassen sich diese beide Variablen auch mit dem Psychologen-Favourite der Mittelwert-Barcharts darstellen.

Dazu gibt es zwei Möglichkeiten.
Entweder wir bauen eine Pipeline, die gruppierte Mittelwerte berechnet und darstellt wie im folgenden Beispiel:

```{r}
palmerpenguins::penguins %>%
  group_by(species) %>% 
  summarise(bill_length_mm = mean(bill_length_mm, na.rm = T)) %>% 
  ggplot(aes(x = species, 
             y = bill_length_mm,
             fill = species)) +
  geom_col()
```


Alternativ können wir das `ggplot`-Feature nutzen, Berechnungen im data-Argument eines geoms anzugeben:

```{r}
palmerpenguins::penguins %>%
  ggplot(aes(x = species, 
             y = bill_length_mm,
             fill = species)) +
  geom_col(data = ~ group_by(.x, species) %>% 
             summarise(bill_length_mm = mean(bill_length_mm, na.rm=T)))
```

:::

### Drei Variablen

Natürlich sind viele der schon genannten `geom`s auch nutzbar, um drei Variablen darzustellen. Mit unserem Beispiel vom Anfang hatten wir z.B. ja schon drei Variablen (`species, bill_length_mm` und `body_mass_g`) auf jeweils eine "Ästhetische Dimension" gemapped. 

Für zum Beispiel Korrelationsdarstellungen könnte ergänzend aber noch `geom_tile` ganz interessant sein. Dazu berechnen wir einmal die Korrelation zwischen allen numerischen Variablen in unserem Datensatz:

```{r}
palmerpenguins::penguins %>% 
  select(where(is.numeric)) %>% 
  cor(., use = 'p')
```

Mit ein bisschen R-Magie machen wir daraus einen `ggplot`-kompatiblen Datensatz mit den drei Variablen x-Dimension, y-Dimension und Korrelation:

```{r}
#| code-fold: true

r <- palmerpenguins::penguins %>%
  select(where(is.numeric)) %>%
  cor(., use = 'p')

r <- tibble(x = rep(row.names(r), nrow(r)),
       y = rep(colnames(r), each=nrow(r)),
       r = c(r))

r
```

Diese drei Dimensionen können wir mit `geom_tile` darstellen:

```{r}
r %>% 
  ggplot(aes(x, y, fill = r)) +
  geom_tile() 
```

Alternativ gibt es selbstverständlich auch ein Paket, das `ggplot2`-basierte Korrelationsmatrizen darstellt:

```{r}
r <- palmerpenguins::penguins %>%
  select(where(is.numeric)) %>%
  cor(., use = 'p')


ggcorrplot::ggcorrplot(r)
```


:::

### Aufgabe

<!-- TODO -->

## Kombination mehrerer `geom`s

Plots müssen nicht nur aus einem `geom` bestehen.

Ein möglicher Fall ist der Wunsch nach der Darstellung von Summary-Statistics in Grafiken mit Rohdaten.

Im Pinguin-Scatter-Plot vom Anfang könnten wir uns zum Beispiel wünschen, die Mittelwerte pro Gruppe darzustellen.
Dazu müssen wir zuerst diesen neuen Datensatz berechnen.
:

```{r}
penguin_means <- palmerpenguins::penguins %>% 
  group_by(species) %>% 
  summarise(across(c(bill_length_mm, 
                     body_mass_g), 
                   ~mean(., na.rm=T)))
```

...und auf den Plot in einem neuen Layer hinzufügen^[alternativ würde natürlich wieder eine (Lambda-)Funktion im data-Argument funktionieren.]:

```{r}
#| warning: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point() +
  geom_point(data=penguin_means)+
  scale_color_viridis_d()
```

Für den Layer können wir dann auch wieder spezifische geometrische Eigenschaften einfügen:

```{r}
#| warning: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point() +
  geom_point(data=penguin_means, shape = 3)+
  scale_color_viridis_d()
```

Oder direkt ein neues Mapping einführen:

```{r}
#| warning: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original')) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'))+
  scale_color_viridis_d()
```

Und auch beide Varianten kombinieren:

```{r}
#| warning: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3)+
  scale_color_viridis_d()
```

Die Kombination von mehreren `geom`s kann außerdem interessant sein, wenn wir verschiedene kombinieren wollen, um mehrere Aspekte abzubilden. So könnte man mehrere der in @sec-geoms besprochenen `geom`s zur Darstellung gleicher Daten auf einem Plot zusammenfügen.

In @fig-multipleGeoms sind Beispiele dargestellt, die mit dem eingeklappten Chunk erstellt wurden, um mit Hilfe mehrerer `geom`s mehr Informationen abzubilden.

```{r}
#| label: fig-multipleGeoms
#| fig-cap: "Abbildungen mit Kombinationen mehrerer `geom`s"
#| fig-subcap: 
#|   - "Zwei kontinuierliche Variablen (+1 diskrete)"
#|   - "Je eine diskrete und eine kontinuierliche Variable"
#| warning: false
#| layout-ncol: 2
#| code-fold: true


palmerpenguins::penguins %>% 
  ggplot(aes(x = flipper_length_mm, 
             y = bill_length_mm,
             color = species)) +
  geom_point(alpha = .5) +
  geom_smooth(method = 'lm') +
  geom_quantile(lty = 3)

palmerpenguins::penguins %>% 
  ggplot(aes(x = species, 
             y = bill_length_mm,
             color = species)) +
  geom_violin(scale = 'area',
              aes(fill = species),
              alpha = .25) +
  geom_boxplot(width = 0.25,
               position = position_nudge(x = -0.125)) +
  geom_dotplot(aes(fill = species),
               binaxis = 'y', 
               stackdir = 'up',
               dotsize = 0.1)
```

## Mehrere `scale`s

Genauso wie die Verwendung mehrerer `geom`s, können natürlich auch mehrere Skalen gesetzt werden. So können wir im Scatter-Plot mit den Mittwelwerten zum Beispiel noch die Symbole für die unterschiedlichen dargestellten Daten anpassen:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))
```

<!-- ## `facet`s und mehrere `geom`s -->

<!-- Nachdem -->

<!-- ```{r} -->
<!-- penguin_means <- palmerpenguins::penguins %>%  -->
<!--   group_by(species, island) %>%  -->
<!--   summarise(across(c(bill_length_mm, body_mass_g),  -->
<!--                    ~mean(., na.rm=T))) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- #| warning: false -->
<!-- palmerpenguins::penguins %>%  -->
<!--   ggplot(aes(x = bill_length_mm,  -->
<!--              y = body_mass_g, -->
<!--              color = species)) +  -->
<!--   geom_point(aes(shape = 'Original'), -->
<!--              alpha = .5) + -->
<!--   geom_point(data=penguin_means, -->
<!--              aes(shape = 'Mittelwert'), -->
<!--              size = 3) + -->
<!--   scale_color_viridis_d(end = 0.7) + -->
<!--   scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+ -->
<!--   coord_fixed(ratio = 10/1000) + -->
<!--   facet_wrap(~island) -->
<!-- ``` -->

## Aufgabe

<!-- TODO -->

# Fortgeschrittene Grafiken mit `ggplot2`

## Styling

`ggplot2` hat neben den in der Grammar of Graphics beschriebenen Komponenten außerdem noch Gruppen von Funktionen die die Usability verbessern oder die Einstellung zur optischen Erscheinung neben den `scales` ermöglichen.

Die wohl wichtigste dieser Funktionen ist die `labs`-Funktion, mit der sich die Beschriftungen des Graphen anpassen lassen:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+
  coord_fixed(ratio = 10/1000) +
  facet_wrap(~island) +
  labs(x = 'Schnabellänge (mm)',
       y = 'Körpergewicht (g)',
       color = 'Pinguin-Spezies',
       shape = 'Aggregations-Niveau')
```


Für eine top-Level-Anpassung der optischen Erscheinung gibt es außerdem die Familie der `theme_` Funktionen. In @fig-themes ist der Pinguin-Plot von eben mit allen in `ggplot2` definierten themes kombiniert.

```{r}
#| warning: false
#| layout-ncol: 3
#| layout-nrow: 3
#| echo: False
#| label: fig-themes
#| fig-cap: "Alle in `ggplot2` angelegten Themes"
#| fig-subcap: 
#|   - "theme_grey"
#|   - "theme_bw"
#|   - "theme_linedraw"
#|   - "theme_light"
#|   - "theme_dark"
#|   - "theme_minimal"
#|   - "theme_classic"
#|   - "theme_void"
#|   - "theme_test"

p <- palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+
  labs(x = 'Schnabellänge (mm)',
       y = 'Körpergewicht (g)',
       color = 'Pinguin-Spezies',
       shape = 'Aggregations-Niveau')

p + theme_grey()

p + theme_bw()

p + theme_linedraw()

p + theme_light()

p + theme_dark()

p + theme_minimal()

p + theme_classic()

p + theme_void()

p + theme_test()

```


Mir gefallen aus dieser Aufstellung "light" und "minimal" am Besten, die anderen sind aber je nach Anlass auch gute Startpunkte.

Unserem Plot können wir das theme wie alle bisherigen layer hinzufügen:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+
  labs(x = 'Schnabellänge (mm)',
       y = 'Körpergewicht (g)',
       color = 'Pinguin-Spezies',
       shape = 'Aggregations-Niveau') +
  theme_light()
```

In diesem Zusammenhang können wir auch gleich Base-Font und Schriftgröße setzen. `theme_light` setzt die kleinste Schriftgröße auf .8 mal die `base_size`^[Diese Info findet man nicht auf der Hilfeseite, wenn man aber in RStudio eine Funktion markiert und F2 drückt, kann man den Quellcode einsehen. `theme_light` ist dabei auch ein gutes Beispiel als Ausgangpunkt für ein eigenes `theme`], wenn wir minimal 8pt große Schrift haben wollen, wie es zum Beispiel von der APA gefordert wird. Außerdem lässt sich eine APA-konforme Schriftart auswählen.
```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+
  labs(x = 'Schnabellänge (mm)',
       y = 'Körpergewicht (g)',
       color = 'Pinguin-Spezies',
       shape = 'Aggregations-Niveau') +
  theme_light(base_family = 'Helvetica',
              base_size = 10)
```

Für genauere Kontrolle der optischen Eigenschaften kann die `theme`-Funktion benutzt werden. Wir kratzen nur mal an der Oberfläche der Möglichkeiten und verschieben die Legende an den unteren Rand des Graphen:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+
  labs(x = 'Schnabellänge (mm)',
       y = 'Körpergewicht (g)',
       color = 'Pinguin-Spezies',
       shape = 'Aggregations-Niveau') +
  theme_light(base_family = 'Helvetica',
              base_size = 10) +
  theme(legend.position = 'bottom')
```

Um die zu breite Beschriftung zu reparieren nutzen wir die `guides`-Funktion ^[`ggplot2` hat eine ganze Familie an `guide_`-Funktionen, die unterschiedliche Legenden-Arten und Legenden-Anpassungen bieten - aus Zeitgründen sei hier aber nur auf deren Existenz verwiesen.]

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+
  labs(x = 'Schnabellänge (mm)',
       y = 'Körpergewicht (g)',
       color = 'Pinguin-Spezies',
       shape = 'Aggregations-Niveau') +
  theme_light(base_family = 'Helvetica',
              base_size = 10) +
  theme(legend.position = 'bottom') +
  guides(color = guide_legend(nrow = 3),
         shape = guide_legend(nrow = 2))
```

### Export

Zum Abschluss wollen wir die Grafiken natürlich exportieren.

Die Textgröße ist in pt gesetzt, deswegen sollten wir nach dem Export die Größe im besten Fall nicht mehr viel ändern.

Eine Din A4-Seite ist 8.2 x 11.6 Zoll groß. Wenn wir eine Grafik auf 80% der Seitenbreite haben wollen, brauchen wir also eine `r 8.2 * .8` Zoll breite Grafik.

Zum Speichern setzen wir unsere Grafik und die Maße in ggsave ein:

```{r}
p <- palmerpenguins::penguins %>% 
  ggplot(aes(x = bill_length_mm, 
             y = body_mass_g,
             color = species)) + 
  geom_point(aes(shape = 'Original'),
             alpha = .5) +
  geom_point(data=penguin_means,
             aes(shape = 'Mittelwert'),
             size = 3) +
  scale_color_viridis_d(end = 0.7) +
  scale_shape_manual(values = c(Original = 20, Mittelwert = 3))+
  labs(x = 'Schnabellänge (mm)',
       y = 'Körpergewicht (g)',
       color = 'Pinguin-Spezies',
       shape = 'Aggregations-Niveau') +
  theme_light(base_family = 'Helvetica',
              base_size = 10) +
  theme(legend.position = 'bottom') +
  guides(color = guide_legend(nrow = 3),
         shape = guide_legend(nrow = 2))

ggsave(plot = p,
       filename = 'imgs/penguin_scatter.png',
       width = 6.56,units = 'in')
```


Der Export sieht so aus:

![Exportierte Grafik](imgs/penguin_scatter.png)

Der Plot ist für meinen Geschmack etwas zu sehr vertikal geraten, das können wir im Export mit "hight" anpassen:

```{r}
ggsave(plot = p,
       filename = 'imgs/shorter_penguin_scatter.png',
       width = 6.56, height = 6, units = 'in')
```


### Convenient Standards

Die beiden `theme`-Funktionen müssten wir so an jede Grafik anfügen. Solche Wiederholungen sind schlechter Stil und stören beim Lesen des Skripts, deswegen bietet `ggplot2` convenience-Funktionen um allgemeine Einstellungen zu setzen. Mit dem folgenden Snippet am Anfang des Skripts werden die Standards für alle Grafiken genutzt:

```{r}
my_theme <-  theme_light(base_family = 'Helvetica',
              base_size = 10) +
  theme(legend.position = 'bottom')

theme_set(my_theme)
```

So kann ich jetzt beispielsweise einfach ein eingefärbtes Histogramm für die Flossen-Länge mit den gesetzten Standards erstellen:

```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(x = flipper_length_mm,
             fill = sex)) +
  geom_histogram(binwidth = 5)
```

## Summary-Layer

Um einer Grafik deskriptive Statistiken hinzuzufügen, gibt es mehrere Möglichkeiten.
Eine haben wir bereits genutzt, indem wir ein geom erstellt haben, dass einen anderen Wert für das `data`-Argument^[Oder halt wieder eine Lambda-Funktion als `data`-Argument] übergeben bekommt:

```{r}
penguin_means <- palmerpenguins::penguins %>% 
  group_by(species) %>% 
  summarise(across(c(bill_length_mm, 
                     body_mass_g), 
                   ~mean(., na.rm=T)))
```

```{r}
#| warning: false
palmerpenguins::penguins %>% 
  ggplot(aes(x = species, 
             y = body_mass_g,
             color = species))+ 
  geom_boxplot(alpha = .5) +
  geom_point(data=penguin_means,
             size = 3)+
  scale_color_viridis_d()
```

Auf diese Art und Weise können wir natürlich beliebig viele Statistiken hinzufügen, so zum Beispiel Mittelwerte +/- SEMs und Text, der Anzahl der in die Mittelwerte einfließenden Werte beziffert:

```{r}
#| warning: false
penguin_means <- palmerpenguins::penguins %>% 
  group_by(species) %>% 
  summarise(across(c(bill_length_mm, 
                     body_mass_g), 
                   .fns = list(mean = ~mean(., na.rm=T),
                               n = ~sum(!is.na(.)),
                               sem = ~sd(., na.rm = T)/sqrt(sum(!is.na(.))))))

penguin_means %>% 
  ggplot(aes(color = species, #<1>
                 x = species, #<1>
                 y = body_mass_g_mean)) +  #<1>
  geom_boxplot(data = palmerpenguins::penguins, #<2>
               aes(y = body_mass_g)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = body_mass_g_mean - body_mass_g_sem,#<3>
                     ymax = body_mass_g_mean + body_mass_g_sem),
                width = 0.5, lty = 2) +#<3>
  geom_text(aes(label = paste('N =', bill_length_mm_n)), #<4>
            position = position_nudge(x = 0.175, y = 30),#<5>
            color = 'black') +
  scale_color_viridis_d()
```

1. Da nur noch der erste `geom_point`-Layer die Koordinaten aus dem original-Datensatz zieht ist das wirklich  einheitliche Mapping auf den gerade erstellten Datensatz bezogen.

2. Alle Layer nach diesem nutzen den erstellten Datensatz - so rum muss nur dem ersten Layer ein extra-Datenargument übergeben werden.

3. `geom_linerange` und `geom_errorbar` brauchen Start- und Endpunkte der Fehlerbalken. Um die Koordinaten zu berechnen, können wir direkt im Mapping eine Funktion, hier den `+`-Operator aufrufen.

4. Mit `paste` fügen wir den String zusammen.

5. Mit `position_nudge` können wir die labels verschieben. Die genauen Werte kann man durch ausprobieren finden. Oder man nutzt das Paket `ggrepel`, das genau dieses Problem löst.

Ab einem bestimmten Punkt werden diese Operationen aber natürlich etwas unübersichtlich.
Für diesen Fall bietet `ggplot2` die `stat_`-Layer und die Lambda-Funktionen im `data`-Argument.

Derselbe Graph lässt sich damit auch wie folgt erstellen:


```{r}
palmerpenguins::penguins %>% 
  ggplot(aes(color = species,
                 x = species,
                 y = body_mass_g)) + 
  geom_boxplot() +
  stat_summary() +
  geom_text(data = ~ group_by(., species) %>%  
              summarise(n = sum(!is.na(body_mass_g)),
                        body_mass_g = mean(body_mass_g, na.rm = T)),
            aes(label = paste('N =', n)),
            position = position_nudge(x = 0.175, y = 30),
            color = 'black') +
  scale_color_viridis_d()
```

Dieser Graph ist auch ein gutes Beispiel, um Faktoren zur Gruppierung von kategorialen aesthetics zu besprechen.

Neben den bisher besprochenen atomaren Variablentypen `logical`, `numeric` und `character` gibt es in R noch das etwas speziellere Format der `factor`s.

`factor`en sind kategoriale Variablen, deren levels eine Ordnung zugewiesen werden kann. `ggplot2` sortiert kategoriale Variablen erstmal nach Alphabet, Faktor-levels werden aber berücksichtigt.

Wir können uns zum Beispiel wünschen, dass die Spezies in der Reihenfolge *Gentoo, Chinstrap, Adelie* aufgelistet werden, also genau umgekehrt.

Dazu können wir die `species`-Variable in einer Pipeline in einen Faktor umwandeln und die levels entsprechend unserer Vorstellung sortieren:

```{r}
palmerpenguins::penguins %>%
  mutate(species = factor(species, levels = c('Gentoo', 'Chinstrap', 'Adelie'))) %>% 
  ggplot(aes(color = species,
                 x = species,
                 y = body_mass_g)) + 
  geom_boxplot() +
  stat_summary() +
  geom_text(data = ~ group_by(., species) %>%  
              summarise(n = sum(!is.na(body_mass_g)),
                        body_mass_g = mean(body_mass_g, na.rm = T)),
            aes(label = paste('N =', n)),
            position = position_nudge(x = 0.175, y = 30),
            color = 'black') +
  scale_color_viridis_d()
```

Wie (so gut wie) immer bietet das `tidyverse` aber auch hier natürlich eine bequemere und felxiblere Lösung.

Mit dem `forcats`-Paket lassen sich Faktoren mit einer Reihe von Ordnungsfunktionen anordnen:

```{r}
#| warning: false
#| layout-ncol: 3
#| layout-nrow: 1
#| echo: False
#| label: fig-forcats
#| fig-cap: "Drei Möglichkeiten, Faktoren mit forcats umzusortieren."
#| fig-subcap: 
#|   - "forcats::fct_infreq(species) - nach Anzahl"
#|   - "forcats::fct_reorder(species, body_mass_g) - nach Median einer anderen Variable"
#|   - "forcats::fct_rev(species) - umgedreht"

p <- \(x) {
  x %>%
    ggplot(aes(color = species,
               x = species,
               y = body_mass_g)) +
    geom_boxplot() +
    stat_summary() +
    geom_text(
      data = ~ group_by(., species) %>%
        summarise(
          n = sum(!is.na(body_mass_g)),
          body_mass_g = mean(body_mass_g, na.rm = T)
        ),
      aes(label = paste('N =', n)),
      position = position_nudge(x = 0.175, y = 30),
      color = 'black'
    ) +
    scale_color_viridis_d()
}

palmerpenguins::penguins %>% 
  mutate(species = forcats::fct_infreq(species)) %>% 
  p()
  
palmerpenguins::penguins %>% 
  mutate(species = forcats::fct_reorder(species, body_mass_g)) %>% 
  p()

palmerpenguins::penguins %>% 
  mutate(species = forcats::fct_rev(species)) %>% 
  p()


```


### Aufgabe

<!-- TODO -->


## Hilfreiche Links

* für einen Überblick über alle möglichen Kompenenten empfiehlt sich [das von posit herausgegebene cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/data-visualization.pdf)

* [das Kapitel zu Datenvisualisierungen](https://r4ds.hadley.nz/data-visualize.html) in @grolemundDataScience2016 ist sehr gut und geht weiter ins Detail als hier möglich ist

* Im Paket [ggpubr](https://rpkgs.datanovia.com/ggpubr/) wird `ggplot2` genutzt um eine Reihe von "publication ready plots" zu erstelllen

* Unter [diesem Link](https://shiny.gmw.rug.nl/ggplotgui/) ist eine shiny-App zur interaktiven Erstellung von ggplot-Graphen zu finden

* Unter [diesem Link](http://www.cookbook-r.com/Graphs/) findet sich eine Sammlung von Farben, Formen, usw., die mit ggplot nutzbar sind.

## Aufgabe

```{r}
#| include: false
#| eval: false

read_csv('../data/example.csv') %>% 
  filter(seq_along(x) %% 10 == 0) %>% 
  transmute(RT = y + 300,
            Accuracy = x/max(x),
            group = as.numeric(as.factor(color))) %>% 
  write_csv('../data/example.csv')
```


1. Lese den [im Repo zu diesem Skript](https://raw.githubusercontent.com/MBrede/r_thesis_tools/main/data/example.csv) zur Verfügung gestellten Datensatz `example.csv` ein. Dazu kann einfach der folgende Chunk genutzt werden:

```{r}
#| eval: false
read_csv('https://raw.githubusercontent.com/MBrede/r_thesis_tools/main/data/example.csv')
```


2. Stelle die Reaktionszeiten und Accuracies in einem Scatterplot dar.

3. Färbe den Graphen nach Gruppen ein

4. Füge Mittelwerte und Standardabweichungen pro Gruppe hinzu. Füge die Standardabweichungen dabei mit `geom_linerange` in zwei layern hinzu (einem für die x- und einem für die y-Richtung)

5. Passe die Grafik so an, dass sie APA-konform ist

6. Mache die Grafik so unästhetisch, wie es die APA-Richtlinien zulassen. [Hier](http://www.cookbook-r.com/Graphs/) sind Fonts, Farben und Formen zu finden.



